#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dirent.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <libevdev/libevdev.h>

#include "roccat-vulcan.h"

#define PIPE_READ_LENGTH 1024

// Neighbor tables
unsigned char rv_neigh[RV_NUM_KEYS][RV_MAX_NEIGH] = {
	0x01, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x02, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x01, 0x03, 0x06, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x02, 0x04, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x03, 0x05, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x04, 0x09, 0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x01, 0x02, 0x07, 0x0b, 0x0c, 0xff, 0xff, 0xff, 0xff,
	0x02, 0x03, 0x06, 0x08, 0x0c, 0x0d, 0xff, 0xff, 0xff, 0xff,
	0x03, 0x07, 0x09, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff,
	0x03, 0x04, 0x05, 0x08, 0x0a, 0x0f, 0xff, 0xff, 0xff, 0xff,
	0x04, 0x05, 0x09, 0x0f, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x06, 0x0c, 0x11, 0x12, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x06, 0x07, 0x0b, 0x0d, 0x11, 0x12, 0xff, 0xff, 0xff, 0xff,
	0x07, 0x08, 0x0c, 0x0e, 0x12, 0x13, 0xff, 0xff, 0xff, 0xff,
	0x08, 0x0d, 0x0f, 0x13, 0x14, 0x15, 0xff, 0xff, 0xff, 0xff,
	0x08, 0x09, 0x0a, 0x0e, 0x10, 0x15, 0xff, 0xff, 0xff, 0xff,
	0x0a, 0x0f, 0x15, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x0b, 0x0c, 0x12, 0x17, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x0b, 0x0c, 0x0d, 0x11, 0x13, 0x17, 0x18, 0xff, 0xff, 0xff,
	0x0d, 0x0e, 0x12, 0x14, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff,
	0x0e, 0x13, 0x15, 0x19, 0x1a, 0x1b, 0xff, 0xff, 0xff, 0xff,
	0x0e, 0x0f, 0x10, 0x14, 0x1b, 0x25, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x11, 0x12, 0x18, 0x1c, 0x1d, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x12, 0x13, 0x17, 0x19, 0x1d, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x13, 0x14, 0x18, 0x1a, 0x1d, 0x1e, 0xff, 0xff, 0xff, 0xff,
	0x14, 0x19, 0x1b, 0x1e, 0x1f, 0x20, 0xff, 0xff, 0xff, 0xff,
	0x14, 0x15, 0x1a, 0x20, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x17, 0x18, 0x1d, 0x21, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x18, 0x19, 0x1c, 0x1e, 0x21, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x19, 0x1a, 0x1d, 0x1f, 0x21, 0x22, 0xff, 0xff, 0xff, 0xff,
	0x1a, 0x1e, 0x20, 0x22, 0x23, 0x24, 0xff, 0xff, 0xff, 0xff,
	0x1a, 0x1b, 0x1f, 0x24, 0x25, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x1d, 0x1e, 0x22, 0x30, 0x31, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x1e, 0x1f, 0x21, 0x23, 0x31, 0x32, 0xff, 0xff, 0xff, 0xff,
	0x1f, 0x22, 0x24, 0x32, 0x33, 0x34, 0xff, 0xff, 0xff, 0xff,
	0x1f, 0x20, 0x23, 0x25, 0x34, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x10, 0x15, 0x1b, 0x20, 0x24, 0x34, 0x39, 0x3f, 0x46, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x1c, 0x21, 0x31, 0x35, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x21, 0x22, 0x30, 0x32, 0x35, 0x36, 0xff, 0xff, 0xff, 0xff,
	0x22, 0x23, 0x31, 0x33, 0x36, 0x37, 0xff, 0xff, 0xff, 0xff,
	0x23, 0x32, 0x34, 0x37, 0x38, 0x39, 0xff, 0xff, 0xff, 0xff,
	0x23, 0x24, 0x25, 0x33, 0x39, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x30, 0x31, 0x36, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x31, 0x32, 0x35, 0x37, 0x3b, 0x3c, 0xff, 0xff, 0xff, 0xff,
	0x32, 0x33, 0x36, 0x38, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff,
	0x33, 0x37, 0x39, 0x3d, 0x3e, 0x3f, 0xff, 0xff, 0xff, 0xff,
	0x25, 0x33, 0x34, 0x38, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x35, 0x36, 0x3c, 0x41, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x36, 0x37, 0x3b, 0x3d, 0x41, 0x42, 0xff, 0xff, 0xff, 0xff,
	0x37, 0x38, 0x3c, 0x3e, 0x42, 0x43, 0xff, 0xff, 0xff, 0xff,
	0x38, 0x3d, 0x3f, 0x43, 0x44, 0x45, 0xff, 0xff, 0xff, 0xff,
	0x25, 0x38, 0x39, 0x3e, 0x45, 0x46, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x3b, 0x3c, 0x42, 0x4e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x3c, 0x3d, 0x41, 0x43, 0x48, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x3d, 0x3e, 0x42, 0x44, 0x48, 0x49, 0xff, 0xff, 0xff, 0xff,
	0x3e, 0x43, 0x45, 0x49, 0x4a, 0x4b, 0xff, 0xff, 0xff, 0xff,
	0x3e, 0x3f, 0x44, 0x46, 0x4b, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x25, 0x3f, 0x45, 0x4b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x42, 0x43, 0x49, 0x4e, 0x4f, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x43, 0x44, 0x48, 0x4a, 0x4f, 0x50, 0xff, 0xff, 0xff, 0xff,
	0x44, 0x49, 0x4b, 0x50, 0x52, 0x60, 0xff, 0xff, 0xff, 0xff,
	0x44, 0x45, 0x4a, 0x52, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x45, 0x46, 0x4b, 0x52, 0x53, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x42, 0x48, 0x4f, 0x54, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x48, 0x49, 0x50, 0x54, 0x55, 0x57, 0xff, 0xff, 0xff, 0xff,
	0x49, 0x4a, 0x4f, 0x57, 0x58, 0x60, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x4a, 0x4b, 0x53, 0x58, 0x59, 0x60, 0xff, 0xff, 0xff, 0xff,
	0x4b, 0x52, 0x59, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x48, 0x4e, 0x4f, 0x55, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x4f, 0x54, 0x56, 0x57, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x55, 0x57, 0x63, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x4f, 0x50, 0x55, 0x56, 0x58, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x50, 0x52, 0x57, 0x60, 0x65, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x52, 0x53, 0x66, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x4a, 0x50, 0x52, 0x58, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x56, 0x64, 0x67, 0x68, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x57, 0x63, 0x65, 0x67, 0x68, 0x69, 0xff, 0xff, 0xff, 0xff,
	0x58, 0x64, 0x68, 0x69, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x59, 0x6a, 0x6b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x63, 0x64, 0x68, 0x6c, 0x6d, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x63, 0x64, 0x65, 0x67, 0x69, 0x6c, 0x6d, 0x6e, 0xff, 0xff,
	0x64, 0x65, 0x68, 0x6a, 0x6d, 0x6e, 0xff, 0xff, 0xff, 0xff,
	0x66, 0x69, 0x6b, 0x6f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x66, 0x6a, 0x6f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x67, 0x68, 0x6d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x67, 0x68, 0x69, 0x6c, 0x6e, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x68, 0x69, 0x6d, 0x72, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x6a, 0x6b, 0x75, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x6d, 0x72, 0x77, 0x78, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x6e, 0x71, 0x73, 0x77, 0x78, 0x79, 0xff, 0xff, 0xff, 0xff,
	0x72, 0x74, 0x78, 0x79, 0x7a, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x6f, 0x73, 0x75, 0x79, 0x7a, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x6f, 0x74, 0x7a, 0x7f, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x71, 0x72, 0x78, 0x7c, 0x7d, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x71, 0x72, 0x73, 0x77, 0x79, 0x7c, 0x7d, 0x7e, 0xff, 0xff,
	0x72, 0x73, 0x74, 0x78, 0x7a, 0x7d, 0x7e, 0x7f, 0xff, 0xff,
	0x73, 0x74, 0x75, 0x79, 0x7e, 0x7f, 0x80, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x77, 0x78, 0x7d, 0x81, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x77, 0x78, 0x79, 0x7c, 0x7e, 0x81, 0x82, 0xff, 0xff, 0xff,
	0x78, 0x79, 0x7a, 0x7d, 0x7f, 0x82, 0x83, 0xff, 0xff, 0xff,
	0x75, 0x79, 0x7a, 0x7e, 0x80, 0x82, 0x83, 0xff, 0xff, 0xff,
	0x75, 0x7a, 0x7f, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x7c, 0x7d, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x7c, 0x7d, 0x7e, 0x81, 0x83, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x7e, 0x7f, 0x80, 0x82, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};


void rv_blend_to(rv_rgb_map *src, rv_rgb_map *dst, rv_rgb tc, int amount) {
	int k, max;
	rv_rgb srgb, drgb;

	for (k = 0; k < RV_NUM_KEYS; k++) {
		srgb = src->key[k];
		drgb = dst->key[k];

		srgb.r = (srgb.r + drgb.r) / 2;
		srgb.g = (srgb.g + drgb.g) / 2;
		srgb.b = (srgb.b + drgb.b) / 2;

		if (abs(tc.r - srgb.r) < amount) srgb.r = tc.r;
		else if (tc.r > srgb.r) srgb.r += amount;
		     else srgb.r -= amount;
		if (abs(tc.g - srgb.g) < amount) srgb.g = tc.g;
		else if (tc.g > srgb.g) srgb.g += amount;
		     else srgb.g -= amount;
		if (abs(tc.b - srgb.b) < amount) srgb.b = tc.b;
		else if (tc.b > srgb.b) srgb.b += amount;
		     else srgb.b -= amount;

		dst->key[k] = srgb;
	}
}

int rv_fx_init() {
	return rv_send_led_map(NULL);
}

unsigned char rv_wheel_offset(unsigned char pos, char offset) {
	return pos + offset;
}

void rv_schedule_impact(unsigned char n0, rv_rgb_map *wheel[], unsigned char wheel_pos, int p1, int p2, rv_rgb c0, rv_rgb c1, rv_rgb c2) {
	int i,j;
	unsigned char seen[RV_NUM_KEYS];

	memset(seen, 0, sizeof(seen));
	wheel[wheel_pos]->key[n0] = c0;
	seen[n0] = 1;

	for (i = 0; i < RV_MAX_NEIGH; i++) {
		unsigned char n1 = rv_neigh[n0][i];
		if (n1 == 0xff) break;
		if (!seen[n1]) wheel[rv_wheel_offset(wheel_pos, p1)]->key[n1] = c1;
		seen[n1] = 1;
	}

	for (i = 0; i < RV_MAX_NEIGH; i++) {
		unsigned char n1 = rv_neigh[n0][i];
		if (n1 == 0xff) break;
		for (j = 0; j < RV_MAX_NEIGH; j++) {
			unsigned char n2 = rv_neigh[n1][j];
			if (n2 == 0xff) break;
			if (!seen[n2]) wheel[rv_wheel_offset(wheel_pos, p2)]->key[n2] = c2;
		}
	}
}

int rv_fx_impact() {
	int k;
	rv_rgb_map *wheel[256];
	unsigned char wheel_pos = 0; // Will overflow 255 => 0
	int ghost_type_pause = 0;

	memset(wheel, 0x00, sizeof(wheel));
	while (wheel[wheel_pos] == NULL) {
		wheel[wheel_pos] = malloc(sizeof(rv_rgb_map));
		if (!wheel[wheel_pos]) {
			rv_printf(RV_LOG_NORMAL, "Error: Unable to allocate memory for wheel\n");
			return(RV_FAILURE);
		}
		memset(wheel[wheel_pos], 0, sizeof(rv_rgb_map));
		wheel_pos++;
	}

	if (rv_init_evdev() != RV_SUCCESS) {
		rv_printf(RV_LOG_NORMAL, "Error: No event input device found\n");
		return(RV_FAILURE);
	}

	while (1) {
		int k, j, i;

		rv_update_evdev();

		k = 0; while (rv_pressed_keys[k] != 0xff) {
			rv_schedule_impact(rv_pressed_keys[k], wheel, wheel_pos, 2, 4, rv_colors[1], rv_colors[2], rv_colors[3]);
			ghost_type_pause = 150; // ~5secs
			k++;
		}

		k = 0; while (rv_repeated_keys[k] != 0xff) {
			rv_schedule_impact(rv_repeated_keys[k], wheel, wheel_pos, 2, 4, rv_colors[1], rv_colors[2], rv_colors[3]);
			ghost_type_pause = 150;
			k++;
		}

		// Ghost typing on random keys
		if (!ghost_type_pause && (rand() % 8 == 0)) {
			unsigned char rkey = rand() >> 23;
			if (rkey < RV_NUM_KEYS && rv_neigh[rkey][0] != 0xff) {
				rv_schedule_impact(rkey, wheel, wheel_pos, 2, 4, rv_colors[4], rv_colors[5], rv_colors[6]);
			}
		}

		rv_send_led_map(wheel[wheel_pos]);

		rv_blend_to(wheel[wheel_pos], wheel[rv_wheel_offset(wheel_pos, 1)], rv_colors[0], 16);

		for (k = 0; k < RV_NUM_KEYS; k++) { wheel[wheel_pos]->key[k] = rv_color_off; };

		NEXT:
		wheel_pos++;
		if (ghost_type_pause) ghost_type_pause--;

		// Runs at ~30fps
		usleep(30000);
	}

	// Should not be reached
	return RV_SUCCESS;
}

int rv_fx_piped(char *pipe_name) {
	rv_rgb_map *rgb_map;
	rv_rgb rgb;
	char *keyname;
	char buf[PIPE_READ_LENGTH];

	rgb_map = malloc(sizeof(rv_rgb_map));
	if (!rgb_map) {
		rv_printf(RV_LOG_NORMAL, "Error: Unable to allocate memory for map\n");
		return(RV_FAILURE);
	}
	memset(rgb_map, 0, sizeof(rv_rgb_map));

	if (rv_init_evdev() != RV_SUCCESS) {
		rv_printf(RV_LOG_NORMAL, "Error: No event input device found\n");
		return(RV_FAILURE);
	}

	rv_printf(RV_LOG_NORMAL, "Reading commands from '%s'\n", pipe_name);

	while (1) {
		FILE *in = fopen(pipe_name, "r");
		struct stat in_stat;
		if (!in) {
			rv_printf(RV_LOG_NORMAL, "Error: %s\n", strerror(errno));
			return(RV_FAILURE);
		}
		if (fstat(fileno(in), &in_stat)) {
			rv_printf(RV_LOG_NORMAL, "Error: %s\n", strerror(errno));
			return(RV_FAILURE);
		}
		if (!S_ISFIFO(in_stat.st_mode)) {
			rv_printf(RV_LOG_NORMAL, "Error: '%s' is not a pipe\n", pipe_name);
			return(RV_FAILURE);
		}

		while (fgets(buf, PIPE_READ_LENGTH, in)) {
			if (sscanf(buf, "%m[^:]:%hd,%hd,%hd", &keyname, &(rgb.r), &(rgb.g), &(rgb.b)) == 4) {
				if (strncmp("all", keyname, 4) == 0) {
					for (int i = 0; i < RV_NUM_KEYS; i++) {
						memcpy(&(rgb_map->key[i]), &rgb, sizeof(rv_rgb));
					}
					rv_printf(RV_LOG_NORMAL, "All keys set to fixed color %hd,%hd,%hd\n", rgb.r, rgb.g, rgb.b);
				}
				else {
					int k = rv_get_keycode(keyname);
					if (k >= 0) {
						memcpy(&(rgb_map->key[k]), &rgb, sizeof(rv_rgb));
						rv_printf(RV_LOG_NORMAL, "Key %s set to fixed color %hd,%hd,%hd\n", keyname, rgb.r, rgb.g, rgb.b);
					}
					else {
						rv_printf(RV_LOG_NORMAL, "Error: Unknown key code '%s'\n", keyname);
					}
				}
			}
			else {
				rv_printf(RV_LOG_NORMAL, "Error: Unable to parse instruction\n");
			}
		}

		rv_send_led_map(rgb_map);

		fclose(in);
	}

	// Should not be reached
	return RV_SUCCESS;
}

int rv_fx_test_loop() {
	rv_rgb_map *rgb_map;
	rv_rgb rgb_off;
	rv_rgb rgb_on;
	int i = 0;

	rgb_map = malloc(sizeof(rv_rgb_map));
	if (!rgb_map) {
		rv_printf(RV_LOG_NORMAL, "Error: Unable to allocate memory for map\n");
		return(RV_FAILURE);
	}
	memset(rgb_map, 0, sizeof(rv_rgb_map));

	if (rv_init_evdev() != RV_SUCCESS) {
		rv_printf(RV_LOG_NORMAL, "Error: No event input device found\n");
		return(RV_FAILURE);
	}

	rgb_off.r = 0;
	rgb_off.g = 0;
	rgb_off.b = 0;

	rgb_on.r = 255;
	rgb_on.g = 255;
	rgb_on.b = 255;

	while (1) {
		memcpy(&(rgb_map->key[i]), &rgb_on, sizeof(rv_rgb));
		memcpy(&(rgb_map->key[(RV_NUM_KEYS + i - 1) % RV_NUM_KEYS]), &rgb_off, sizeof(rv_rgb));
		rv_printf(RV_LOG_NORMAL, "Key %d -> %s\n", i, libevdev_event_code_get_name(EV_KEY, rv_rv2ev(i)));
		rv_send_led_map(rgb_map);
		// 1 second
		usleep(1000000);
		i = (i + 1) % RV_NUM_KEYS;
	}

	// Should not be reached
	return RV_SUCCESS;
}
